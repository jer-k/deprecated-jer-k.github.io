{"componentChunkName":"component---src-templates-post-template-js","path":"/apline-linux-docker-authentication-with-pass","result":{"data":{"markdownRemark":{"id":"8dbb13b1-729d-5578-8e59-4fd433e5f6d7","html":"<p><img src=\"media/insecure_docker_login.png\" alt=\"insecure docker login\"></p>\n<p>If you’ve ever encountered the above message when logging into Docker and thought to yourself “Well it’s unencrypted but it works… I’ll deal with it another day” then we’ve got something in common. That day finally came when I was working on another blog post but realized that without a secure way to do a <code class=\"language-text\">docker login</code> I was never going to achieve a good working example to write about. I came across <a href=\"https://github.com/docker/docker-credential-helpers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">docker-credential-helpers</a> which looked like exactly what I needed. One of the recommended ways to store the encrypted passwords is with <a href=\"https://www.passwordstore.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pass</a>. However, once I started looking at <code class=\"language-text\">pass</code>, I wasn’t really sure where to start on getting everything working. Apparently I was not alone because after some googling I came across an issue on the <code class=\"language-text\">docker-credential-helpers</code> Github titled <a href=\"https://github.com/docker/docker-credential-helpers/issues/102\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Document how to initialize docker-credentials-pass</a>. After reading through all of the discussion I felt like I understood enough to set out and figure out once and for all how to get rid of the pesky Docker warning.</p>\n<p>If you prefer, you can view the <a href=\"https://github.com/jer-k/alpine_docker_pass/blob/master/Dockerfile\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dockerfile</a> on Github, otherwise continue reading and I’ll show the entire file, then break down each piece.</p>\n<deckgo-highlight-code language=\"docker\"  >\n          <code slot=\"code\"># syntax = docker/dockerfile:experimental\nFROM alpine\n\nENV USER=docker_user\nENV HOME=/home/$USER\n\nRUN addgroup -S appgroup &amp;&amp; adduser -u 1001 -S $USER -G appgroup\n\nRUN apk --update upgrade &amp;&amp; apk add --update  docker \\\n                                              gnupg \\\n                                              pass\n\n# As of 7/10/2020 the latest release of docker-credential-helpers is 0.6.3\nRUN wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz \\\n    &amp;&amp; tar -xf docker-credential-pass-v0.6.3-amd64.tar.gz \\\n    &amp;&amp; chmod +x docker-credential-pass \\\n    &amp;&amp; mv docker-credential-pass /usr/local/bin/ \\\n    &amp;&amp; rm docker-credential-pass-v0.6.3-amd64.tar.gz\n\n# Create the .docker directory, copy in the config.json file which sets the credential store as pass, and set the correct permissions\nRUN mkdir -p $HOME/.docker/\nCOPY config.json $HOME/.docker/\nRUN chown -R $USER:appgroup $HOME/.docker\nRUN chmod -R 755 $HOME/.docker\n\n# Create the .gnupg directory and set the correct permissions\nRUN mkdir -p $HOME/.gnupg/\nRUN chown -R $USER:appgroup $HOME/.gnupg\nRUN chmod -R 700 $HOME/.gnupg\n\nWORKDIR $HOME\nUSER $USER\n\nCOPY gpg_file.txt .\n\n# Edit the gpg file to add our password and generate the key\nRUN --mount=type=secret,id=gpg_password,uid=1001 cat gpg_file.txt | sed &#39;s/gpg_password/&#39;&quot;`cat /run/secrets/gpg_password`&quot;&#39;/g&#39; | gpg --batch --generate-key\n\n# Generate the pass store by accessing and passing the gpg fingerprint\nRUN pass init $(gpg --list-secret-keys dockertester@docker.com | sed -n &#39;/sec/{n;p}&#39; | sed &#39;s/^[[:space:]]*//g&#39;)\n\n# Login to Docker\nARG DOCKER_USER\nRUN --mount=type=secret,id=docker_password,uid=1001 cat /run/secrets/docker_password | docker login --username $DOCKER_USER --password-stdin\n\n# Using cat will keep the container running\nCMD [&quot;cat&quot;]</code>\n        </deckgo-highlight-code>\n<p>Alright, that was the Dockerfile in its entirety so let’s jump into explaining what is going on.</p>\n<deckgo-highlight-code language=\"docker\"  >\n          <code slot=\"code\"># syntax = docker/dockerfile:experimental\nFROM alpine\n\nENV USER=docker_user\nENV HOME=/home/$USER\n\nRUN addgroup -S appgroup &amp;&amp; adduser -u 1001 -S $USER -G appgroup\n\nRUN apk --update upgrade &amp;&amp; apk add --update  docker \\\n                                              gnupg \\\n                                              pass</code>\n        </deckgo-highlight-code>\n<p>First off, I’m using features from Docker’s <a href=\"https://github.com/moby/buildkit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BuildKit</a> and the first line <code class=\"language-text\"># syntax = docker/dockerfile:experimental</code> enables these features. If you haven’t read about the experimental features, you can do so <a href=\"https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>. I’m going to use <a href=\"https://alpinelinux.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Alpine Linux</a> as my base image, as it has been my go to for building Docker images for quite some time now. I’ve added a user and set up a new home directory so that we can run the image as a non-root user. The last piece here is adding the packages we’ll need: <code class=\"language-text\">docker</code> because that’s what we’re trying to log into, <code class=\"language-text\">gnupg</code> to generate a certificate for seeding <code class=\"language-text\">pass</code>, and <code class=\"language-text\">pass</code> to securely store our credentials.</p>\n<deckgo-highlight-code language=\"docker\"  >\n          <code slot=\"code\"># As of 7/10/2020 the latest release of docker-credential-helpers is 0.6.3\nRUN wget https://github.com/docker/docker-credential-helpers/releases/download/v0.6.3/docker-credential-pass-v0.6.3-amd64.tar.gz \\\n    &amp;&amp; tar -xf docker-credential-pass-v0.6.3-amd64.tar.gz \\\n    &amp;&amp; chmod +x docker-credential-pass \\\n    &amp;&amp; mv docker-credential-pass /usr/local/bin/ \\\n    &amp;&amp; rm docker-credential-pass-v0.6.3-amd64.tar.gz</code>\n        </deckgo-highlight-code>\n<p>Next we’ll install <code class=\"language-text\">docker-credential-helpers</code> and one of the first comments on the aforementioned issue <a href=\"https://github.com/docker/docker-credential-helpers/issues/102#issuecomment-388974092\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">showed</a> how to do this. I just modified the release number to get the most up to date version.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># Create the .docker directory, copy in the config.json file which sets the credential store as pass, and set the correct permissions\nRUN mkdir -p $HOME/.docker/\nCOPY config.json $HOME/.docker/\nRUN chown -R $USER:appgroup $HOME/.docker\nRUN chmod -R 755 $HOME/.docker</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># config.json file\n\n{\n  &quot;credsStore&quot;: &quot;pass&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>Now we need to create our <code class=\"language-text\">.docker</code> directory and ensure that our user has full control over it. We copy in the <code class=\"language-text\">config.json</code> file which tells Docker to use <code class=\"language-text\">pass</code> as a credential store.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># Create the .gnupg directory and set the correct permissions\nRUN mkdir -p $HOME/.gnupg/\nRUN chown -R $USER:appgroup $HOME/.gnupg\nRUN chmod -R 700 $HOME/.gnupg</code>\n        </deckgo-highlight-code>\n<p>After a little bit of trial and error, I discovered that I needed a <code class=\"language-text\">.gnupg</code> directory with correct permissions before <code class=\"language-text\">gpg</code> would allow me to generate the key. With that, everything is now set up to start generating our secure login.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">WORKDIR $HOME\nUSER $USER\n\nCOPY gpg_file.txt .\n\n# Edit the gpg file to add our password and generate the key\nRUN --mount=type=secret,id=gpg_password,uid=1001 cat gpg_file.txt | sed &#39;s/gpg_password/&#39;&quot;`cat /run/secrets/gpg_password`&quot;&#39;/g&#39; | gpg --batch --generate-key</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># gpg_file.txt\n\n# Example from https://www.gnupg.org/documentation//manuals/gnupg/Unattended-GPG-key-generation.html\n%echo Generating a basic OpenPGP key\nKey-Type: DSA\nKey-Length: 1024\nSubkey-Type: ELG-E\nSubkey-Length: 1024\nName-Real: Docker Tester\nName-Email: dockertester@docker.com\nExpire-Date: 0\nPassphrase: gpg_password\n# Do a commit here, so that we can later print &quot;done&quot; :-)\n%commit\n%echo done</code>\n        </deckgo-highlight-code>\n<p>There is a bit to unpack here, but first we set our <code class=\"language-text\">WORKDIR</code> to the <code class=\"language-text\">$HOME</code> directory and change from the root user to our <code class=\"language-text\">$USER</code>. Next we copy in the <code class=\"language-text\">gpg_file.txt</code> file shown above, which is a modified example from <a href=\"https://www.gnupg.org/documentation//manuals/gnupg/Unattended-GPG-key-generation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gnupg.org</a>. The <code class=\"language-text\">RUN</code> line can be broken down into a few different pieces so we’ll go through it piece by piece.</p>\n<p><code class=\"language-text\">--mount=type=secret,id=gpg_password,uid=1001</code> is taking advantage of using <a href=\"https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md#run---mounttypesecret\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BuildKit secrets</a>. If you want to read about BuildKit secrets, I would suggest the official Docker documentation <a href=\"https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">New Docker Build secret information</a>, however the gist of this functionality is that the secret is only supplied to this single <code class=\"language-text\">RUN</code> command and is not left behind as an artifact in the layer. The command is saying to make available the mounted secret at <code class=\"language-text\">id=gpg_password</code> and access it as user 1001 (which we set when we generated the user).</p>\n<p>As a side note, I would have created a <code class=\"language-text\">$USER_UID</code> environment variable instead of hard coding the uid, but this mount command cannot interpret a Docker environment variable (see BuildKit issue <a href=\"https://github.com/moby/buildkit/issues/815\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">815</a>).</p>\n<p><code class=\"language-text\">cat gpg_file.txt | sed 's/gpg_password/'\"&amp;96cat /run/secrets/gpg_password&amp;96\"'/g' |</code> is piping the contents of our <code class=\"language-text\">gpg_file.txt</code> file into <code class=\"language-text\">sed</code> where we’re doing a find on <code class=\"language-text\">gpg_password</code> and replacing it by accessing our mounted secret at and outputting the value through <code class=\"language-text\">cat</code>.</p>\n<p><code class=\"language-text\">gpg --batch --generate-key</code> is receiving the contents of the file, with our password in place and generating the key in unattended mode via the <code class=\"language-text\">--batch</code> flag. With that we’ve successfully generated a key we can use to seed <code class=\"language-text\">pass</code>.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># Generate the pass store by accessing and passing the gpg fingerprint\nRUN pass init $(gpg --list-secret-keys dockertester@docker.com | sed -n &#39;/sec/{n;p}&#39; | sed &#39;s/^[[:space:]]*//g&#39;)</code>\n        </deckgo-highlight-code>\n<p>Again we’ve got multiple commands on a single line so let’s break those down.</p>\n<p><code class=\"language-text\">pass init</code> is ultimately what we’re trying to accomplish which will initialize our password store.</p>\n<p><code class=\"language-text\">gpg --list-secret-keys dockertester@docker.com</code> is how the example from <a href=\"https://www.gnupg.org/documentation//manuals/gnupg/Unattended-GPG-key-generation.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gnupg.org</a> says to see the keys we’ve generated. The example output is as follows</p>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">$ gpg --list-secret-keys dockertester@docker.com\nsec   dsa1024 2020-07-12 [SCA]\n      D48ED9A99CFDDBD8B3D08A6EA4BEBAE5B209C126\nuid           [ultimate] Docker Tester &lt;dockertester@docker.com&gt;\nssb   elg1024 2020-07-12 [E]</code>\n        </deckgo-highlight-code>\n<p>That output is piped into <code class=\"language-text\">sed -n '/sec/{n;p}'</code> which finds the match of <code class=\"language-text\">sec</code>, then goes to the <code class=\"language-text\">n</code>ext line and <code class=\"language-text\">p</code>rints it. A larger explanation can be found in <a href=\"https://unix.stackexchange.com/a/31535\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this Stack Overflow answer</a>. This command returns <code class=\"language-text\">D48ED9A99CFDDBD8B3D08A6EA4BEBAE5B209C126</code>, which is our gpg key, but it includes the whitespace.</p>\n<p>The last command, <code class=\"language-text\">sed 's/^[[:space:]]*//g'</code>, takes in the key with the whitespace and removes all the whitespace so we’re left with just the key, which is used by <code class=\"language-text\">pass init</code>. Now we’re ready to securely log into Docker!</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># Login to Docker\nARG DOCKER_USER\nRUN --mount=type=secret,id=docker_password,uid=1001 cat /run/secrets/docker_password | docker login --username $DOCKER_USER --password-stdin</code>\n        </deckgo-highlight-code>\n<p>By calling <code class=\"language-text\">ARG DOCKER_USER</code> we’re making that build argument available to us via <code class=\"language-text\">$DOCKER_USER</code>. Then we’re using the same secret syntax as the previous <code class=\"language-text\">RUN</code> command, but this time accessing <code class=\"language-text\">docker_password</code> and piping the password into the <code class=\"language-text\">docker login</code> command that was suggested from the original warning output seen in the screenshot as the beginning of the article.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\"># Using cat will keep the container running\nCMD [&quot;cat&quot;]</code>\n        </deckgo-highlight-code>\n<p>The final piece of the <code class=\"language-text\">Dockerfile</code> is the command, which is <code class=\"language-text\">cat</code> for the sole purpose of keeping the container running for this demo. Now that we’ve covered the contents of the <code class=\"language-text\">Dockerfile</code>, the next step is to build the image.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">$ DOCKER_BUILDKIT=1 docker build -t alpine_docker_pass --secret id=gpg_password,src=gpg_password.txt --secret id=docker_password,src=docker_password.txt --build-arg DOCKER_USER=your_docker_username .</code>\n        </deckgo-highlight-code>\n<p>Let’s do another breakdown.</p>\n<p><code class=\"language-text\">DOCKER_BUILDKIT=1</code> is the instruction to enable BuildKit.</p>\n<p><code class=\"language-text\">docker build -t alpine_docker_pass</code> is the standard <code class=\"language-text\">docker build</code> and tagging the image as <code class=\"language-text\">alpine_docker_pass</code>.</p>\n<p><code class=\"language-text\">--secret id=gpg_password,src=gpg_password.txt</code> and <code class=\"language-text\">--secret id=docker_password,src=docker_password.txt</code> are our BuildKit enabled arguments to mount text files as secrets in the image. Inside of each file I have a single line with the password.</p>\n<p><code class=\"language-text\">--build-arg DOCKER_USER=your_docker_username</code> is setting our build argument for <code class=\"language-text\">DOCKER_USER</code>. Don’t forget to replace <code class=\"language-text\">your_docker_username</code> with your actual Docker username!</p>\n<p><code class=\"language-text\">.</code> finally the lonesome dot to instruct <code class=\"language-text\">docker build</code> to run in the current working directory.</p>\n<p>If you to want stop here, I don’t blame you. We’ve covered all the pieces of the <code class=\"language-text\">Dockerfile</code> and the command you’ll need to properly build the image. What follows is the practical example, which takes a bit of set up. I won’t be breaking everything down in as much detail to help with conciseness. We’re going to set up a <code class=\"language-text\">docker-compose.yml</code> file that will use our built image and <a href=\"https://github.com/docker-library/docker/blob/93c19dff54de9876f736b3aa8026be5ad5987388/19.03/dind/Dockerfile\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dind</a> so we have a daemon to connect to. We’ll run the images, exec into the container, and then ensure that everything works. Let’s get to it!</p>\n<deckgo-highlight-code language=\"docker\"  >\n          <code slot=\"code\">version: &#39;3&#39;\n\nservices:\n  alpine_docker_pass:\n    image: localhost:5000/alpine_docker_pass:latest\n    environment:\n      DOCKER_HOST: tcp://docker:2376\n      DOCKER_TLS_VERIFY: 1\n      DOCKER_CERT_PATH: /certs/client\n    volumes:\n      - certs:/certs/client\n    stdin_open: true\n    tty: true\n\n  docker:\n    # Starts a Docker daemon at the DNS name &quot;docker&quot;\n    # Note:\n    #  * This must be called &quot;docker&quot; to line up with the default\n    #    TLS certificate name\n    #  * DOCKER_TLS_CERTDIR defaults to &quot;/certs\n    image: docker:19.03-dind\n    privileged: yes\n    volumes:\n      - certs:/certs/client\n\nvolumes:\n  certs:</code>\n        </deckgo-highlight-code>\n<p>Awhile ago I came across this article <a href=\"https://www.caktusgroup.com/blog/2020/02/25/docker-image/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How to Use the “docker” Docker Image to Run Your Own Docker daemon</a> that explained how to set up a compose file with <code class=\"language-text\">dind</code>; it is a very good read and I highly recommend it. I borrowed most of the setup from that article, the only interesting thing to note here is <code class=\"language-text\">image: localhost:5000/alpine_docker_pass:latest</code>. We need a way to reference our locally built image and we can do that via <code class=\"language-text\">docker tag alpine_docker_pass:latest localhost:5000/alpine_docker_pass:latest</code>. The port on localhost can be anything; there does not need to be a real running server on that port. By tagging our image this way, we ensure that docker will pull our local image and not try to pull an image from Dockerhub. However, I have also pushed the same image to a private repository on my Dockerhub account so that I can test the authentication from the container for the purpose of this example. Let’s run the compose file.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">$ docker-compose up -d\n$ docker exec -it alpine_docker_pass_alpine_docker_pass_1 /bin/bash</code>\n        </deckgo-highlight-code>\n<p>The following commands are run from inside the container and are denoted by the <code class=\"language-text\">bash-5.0</code> prefix.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">bash-5.0$ docker pull itsjerk/alpine_docker_pass\nUsing default tag: latest\nError response from daemon: pull access denied for itsjerk/alpine_docker_pass, repository does not exist or may require &#39;docker login&#39;: denied: requested access to the resource is denied</code>\n        </deckgo-highlight-code>\n<p>First a quick test to show that we aren’t authenticated and can’t pull the image.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">bash-5.0$ pass\nPassword Store\n└── docker-credential-helpers\n    └── aHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEv\n        └── itsjerk\nbash-5.0$ pass docker-credential-helpers/aHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEv/itsjerk\n&lt;mypassword&gt;bash-5.0$</code>\n        </deckgo-highlight-code>\n<p>Next we can list out our saved passwords by calling <code class=\"language-text\">pass</code> and initiate the log in by calling <code class=\"language-text\">pass docker-credential-helpers/aHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEv/itsjerk</code>. We are then prompted to put in our password which was in the <code class=\"language-text\">gpg_password.txt</code> file. <code class=\"language-text\">pass</code> will spit out your password (without a newline at the end!) if everything works. I have redacted my own password.</p>\n<deckgo-highlight-code   highlight-lines=\"undefined\">\n          <code slot=\"code\">bash-5.0$ docker login\nAuthenticating with existing credentials...\nLogin Succeeded\nbash-5.0$ docker pull itsjerk/alpine_docker_pass\nUsing default tag: latest\nlatest: Pulling from itsjerk/alpine_docker_pass\nDigest: sha256:f35cfb2bd0887d32347e3638fd53df4ead898de309c516f8e16b959232b84280\nStatus: Image is up to date for itsjerk/alpine_docker_pass:latest\ndocker.io/itsjerk/alpine_docker_pass:latest</code>\n        </deckgo-highlight-code>\n<p>Finally we can log into Docker without having to supply our Docker password or receiving any warning! We test the authentication by pulling the same private image from before and see that we can successfully pull it.</p>\n<p>If you made it all the way to the end, I hope you learned a thing or two; I definitely did while putting all this together! Overall this is a lot of work to ensure that your Docker password is stored in a secure way but it is always better to be on the safe side when it comes to container security.</p>","fields":{"slug":"apline-linux-docker-authentication-with-pass","tagSlugs":["/tag/docker/","/tag/authentication/","/tag/authenticate/","/tag/alpine-linux/","/tag/pass/","/tag/docker-credential-helpers/"]},"excerpt":"<p><img src=\"media/insecure_docker_login.png\" alt=\"insecure docker login\"></p>\n<p>If you’ve ever encountered the above message when logging into Docker and thought to yourself “Well it’s unencrypted but it works… I’ll…</p>","frontmatter":{"date":"2020-07-31","description":"If you've ever encountered the above message when logging into Docker and thought to yourself 'Well it’s unencrypted but it works... I'll deal with it another day' then we've got something in common.","tags":["docker","authentication","authenticate","alpine-linux","pass","docker-credential-helpers"],"title":"Secure Docker Authentication with Pass on Alpine Linux"}}},"pageContext":{"slug":"apline-linux-docker-authentication-with-pass"}},"staticQueryHashes":["251939775","2920561799","401334301"]}