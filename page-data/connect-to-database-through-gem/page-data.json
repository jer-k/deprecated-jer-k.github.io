{"componentChunkName":"component---src-templates-post-template-js","path":"/connect-to-database-through-gem","result":{"data":{"markdownRemark":{"id":"ceb2a02b-cb0e-54da-8336-8cc0d3576beb","html":"<p>I was recently thinking about system design, specifically the monolithic vs microservices approaches and how applications can talk to each other. If I needed to connect two applications, I would start by exposing APIs and using <a href=\"https://github.com/lostisland/faraday\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Faraday</a> to write a simple HTTP client to consume the APIs. However, APIs can have their own set of issues (a discussion for another day) and an idea popped into my head to allow applications to connect directly to the database of another application through a gem that exposes the classes. I would only consider this approach internal applications and even then, you could totally cripple your system if someone starts writing queries without knowing what they are doing. But I was curious and wanted to try this approach out so let’s get started with creating our gem!</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">bundle gem books_gem</code>\n        </deckgo-highlight-code>\n<p>We’ll need to add ActiveRecord as a dependency to the <code class=\"language-text\">books_gem.gemspec</code>.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\"> spec.add_dependency &#39;activerecord&#39;, &#39;~&gt; 5&#39;</code>\n        </deckgo-highlight-code>\n<p>Next, create a base class at <code class=\"language-text\">lib/books_gem/models/base.rb</code></p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;active_record&#39;\nrequire &#39;books_gem/db/books_gem_db&#39;\n\nmodule BooksGem\n  class Base &lt; ::ActiveRecord::Base\n    self.abstract_class = true\n    establish_connection(BOOKS_GEM_DB[Rails.env])\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>and a few subclasses.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;books_gem/models/base&#39;\n\nmodule BooksGem\n  class Book &lt; Base\n  end\nend</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;books_gem/models/base&#39;\n\nmodule BooksGem\n  class Author &lt; Base\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>The <a href=\"http://api.rubyonrails.org/classes/ActiveRecord/ConnectionHandling.html#method-i-establish_connection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">establish_connection</a> call allows us to tell <code class=\"language-text\">ActiveRecord</code> how, and where, we’re going to connect to a database. Since this is our base class, the connection will only be established once, and all our subclasses will know where their database resides. If you would like to read more about why you should only establish a single connection, Sophie DeBenedetto wrote a great blog post, <a href=\"http://www.thegreatcodeadventure.com/managing-multiple-databases-in-a-single-rails-application/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Managing Multiple Databases in a Single Rails Application</a>, going much further in depth on that topic; kudos to her, she provided much of the inspiration for my work on this idea.</p>\n<p>Since this is a gem, we want our connection to be configurable for anyone who uses it. The <code class=\"language-text\">BOOKS_GEM_DB</code> constant will provide this configurability, which we’ll create at <code class=\"language-text\">lib/books_gem/db/books_gem_db.rb</code>.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;yaml&#39;\nrequire &#39;erb&#39;\n\ndb_dir = File.expand_path(&#39;../&#39;, __FILE__)\nBOOKS_GEM_DB = YAML.load(ERB.new(IO.read(File.join(db_dir, &#39;books_gem_database.yml&#39;))).result)</code>\n        </deckgo-highlight-code>\n<p>The YAML file will be located at <code class=\"language-text\">lib/books_gem/db/books_gem_database.yml</code>.</p>\n<deckgo-highlight-code language=\"yaml\"  >\n          <code slot=\"code\">default: &amp;default\n  adapter: postgresql\n  encoding: unicode\n  pool: 5\n  port: 5432\n\nlocal: &amp;local\n  host: &lt;%= ENV[&#39;BOOKS_GEM_DB_HOST&#39;] %&gt;\n  username: &lt;%= ENV[&#39;BOOKS_GEM_DB_USER&#39;] %&gt;\n  password: &lt;%= ENV[&#39;BOOKS_GEM_DB_PASSWORD&#39;] %&gt;\n\ndevelopment:\n  &lt;&lt;: *default\n  &lt;&lt;: *local\n  database: &lt;%= ENV[&#39;BOOKS_GEM_DB_DEVELOPMENT&#39;] %&gt;\n\ntest:\n  &lt;&lt;: *default\n  &lt;&lt;: *local\n  database: &lt;%= ENV[&#39;BOOKS_GEM_DB_TEST&#39;] %&gt;</code>\n        </deckgo-highlight-code>\n<p>What we’re doing here is getting the full file path for the <code class=\"language-text\">lib/books_gem/db</code> directory based off the location of <code class=\"language-text\">books_gem_db.rb</code> file. We use that file path to open the <code class=\"language-text\">books_gem_database.yml</code> file and read its contents into an ERB object. As you saw above, we’re using ERB templating in the YAML file to read environment variables that tell us where the database resides and how to connect to it. Finally, we load the YAML and save it into the <code class=\"language-text\">BOOKS_GEM_DB</code> constant.</p>\n<p>The last thing we need to do is expose all our classes in <code class=\"language-text\">lib/books_gem.rb</code> so that applications who install the gem can use them.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &quot;books_gem/version&quot;\n\nrequire &#39;books_gem/models/book&#39;\nrequire &#39;books_gem/models/author&#39;</code>\n        </deckgo-highlight-code>\n<p>That concludes writing the gem. There is an example project located at <a href=\"https://github.com/jer-k/api_to_gem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/jer-k/api<em>to</em>gem</a> with instructions in the <a href=\"https://github.com/jer-k/api_to_gem/blob/master/README.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">README</a> on how to test out the gem. There is one last gotcha, which is ensuring that the environment variables from the Rails application are available when the gem loads. I prefer to use <a href=\"https://github.com/bkeepers/dotenv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dotenv</a> and we would install it using the <code class=\"language-text\">rails-now</code> preference</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">gem &#39;dotenv-rails&#39;, require: &#39;dotenv/rails-now&#39;\ngem &#39;books_gem&#39;, path: path/to/books_gem</code>\n        </deckgo-highlight-code>\n<p>Then we can set our environment variables in the Rails application and be done.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">BOOKS_GEM_DB_HOST=localhost\nBOOKS_GEM_DB_USER=books_user\nBOOKS_GEM_DB_PASSWORD=books\nBOOKS_GEM_DB_DEVELOPMENT=books_api_development\nBOOKS_GEM_DB_TEST=books_api_test</code>\n        </deckgo-highlight-code>\n<p>We’ve successfully connected from one Rails application to another Rails application’s database and are free to write queries to our hearts content!</p>","fields":{"slug":"connect-to-database-through-gem","tagSlugs":["/tag/ruby/","/tag/rails/","/tag/ruby-gems/","/tag/ruby-on-rails/","/tag/postgres/","/tag/postgresql/","/tag/database/"]},"excerpt":"<p>I was recently thinking about system design, specifically the monolithic vs microservices approaches and how applications can talk to each…</p>","frontmatter":{"date":"2018-02-18","description":"I was recently thinking about system design, specifically the monolithic vs microservices approaches and how applications can talk to each other.","tags":["ruby","rails","ruby-gems","ruby-on-rails","postgres","postgresql","database"],"title":"Connect To Another Rails Application's Database Through A Gem"}}},"pageContext":{"slug":"connect-to-database-through-gem"}},"staticQueryHashes":["251939775","2920561799","401334301"]}