{"componentChunkName":"component---src-templates-post-template-js","path":"/testing-and-developer-scripts-for-active-record-gem","result":{"data":{"markdownRemark":{"id":"fa384bfe-4ea8-57d9-b319-b88f86e85b5a","html":"<p>Continuing to work on our <a href=\"https://jer-k.github.io/add-active-record-rake-tasks-to-gem/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gem with active_record rake tasks</a>, we still need to set up a testing environment that can be run locally and in a repeatable fashion for continuous integration; we’ll accomplish the latter using a simple Dockerfile. But first let’s make it easier for someone to start using the gem by enhancing the scripts in <code class=\"language-text\">bin/</code>.</p>\n<p>We’ll start off by changing <code class=\"language-text\">bin/setup</code> to create the user and the database.</p>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">#!/usr/bin/env bash\nset -euo pipefail\nIFS=$&#39;\\n\\t&#39;\nset -vx\n\nbundle install\n\npsql -tAc &quot;SELECT 1 FROM pg_roles WHERE rolname=&#39;gem_with_database&#39;&quot; | grep -q 1 || \\\npsql -c &quot;create role gem_with_database with superuser login password &#39;password&#39;&quot;\n\npsql -tAc &quot;SELECT 1 FROM pg_database WHERE datname=&#39;gem_with_database_development&#39;&quot; | grep -q 1 || \\\nrake db:create db:migrate db:seed</code>\n        </deckgo-highlight-code>\n<p>The first command queries the <code class=\"language-text\">pg_roles</code> table looking to see if there is a role named <code class=\"language-text\">gem_with_database</code> and returns 1 if so. The result is piped into <code class=\"language-text\">grep</code> looking for the 1, if it is found we stop, otherwise we issue another command to create the <code class=\"language-text\">gem_with_database</code> role. If you’re curious as to how this works, <code class=\"language-text\">grep</code> returns a non-zero exit code if it doesn’t find something and a bash <code class=\"language-text\">||</code> only evaluates the right-hand side of the expression if the left-hand side has a non-zero value.\nWe follow the same pattern in the second command and look to see if a database named <code class=\"language-text\">gem_with_database_development</code> exists; if it doesn’t we create it and add our data.</p>\n<p>Once the database is created and has data in it, we want to start playing around with our models and we can ensure everything is ready by modifying <code class=\"language-text\">bin/console</code>.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">#!/usr/bin/env ruby\n\nrequire &#39;bundler/setup&#39;\nrequire &#39;gem_with_database&#39;\nrequire &#39;active_record&#39;\nrequire &#39;logger&#39;\nrequire &#39;pry&#39;\n\nActiveRecord::Base.establish_connection(\n  :adapter =&gt; &#39;postgresql&#39;,\n  :database =&gt; &#39;gem_with_database_development&#39;\n)\nActiveRecord::Base.logger = Logger.new(STDOUT)\n\nPry.start</code>\n        </deckgo-highlight-code>\n<p>We simply require the needed gems to establish a connection to the database, setup logging so we can see the results of the queries, and my personal preference is to use a <code class=\"language-text\">Pry</code> console. With that a user can clone the repository, run <code class=\"language-text\">bin/setup</code> and then <code class=\"language-text\">bin/console</code> and be able to query data!</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">[1] pry(main)&gt; GemWithDatabase::Book.first\nD, [2018-03-10T17:49:22.051607 #31929] DEBUG -- :   GemWithDatabase::Book Load (4.5ms)  SELECT  &quot;books&quot;.* FROM &quot;books&quot; ORDER BY &quot;books&quot;.&quot;id&quot; ASC LIMIT $1  [[&quot;LIMIT&quot;, 1]]\n=&gt; #&lt;GemWithDatabase::Book:0x00007f8e9cdf6e70\n id: 1,\n title: &quot;A Game of Thrones&quot;,\n pages: 694,\n published: 1996,\n author_id: 1&gt;</code>\n        </deckgo-highlight-code>\n<p>Now that we have everyone up and running with a development environment, we need to setup our testing environment. The first thing we will do is add <a href=\"https://github.com/thoughtbot/factory_bot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">FactoryBot</a> so we can create mock data.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">spec.add_dependency &#39;factory_bot&#39;, `~&gt; 4`</code>\n        </deckgo-highlight-code>\n<p>It is added as a normal dependency because we can actually export our factories so that anyone who uses the gem gets an added bonus of being able to create mock data right off the bat, instead of having to define their own.</p>\n<p>We’ll create <code class=\"language-text\">lib/gem_with_database/factories/author.rb</code>.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;factory_bot&#39;\n\nFactoryBot.define do\n  factory :gem_with_database_author, class: GemWithDatabase::Author do\n    name &#39;Test Author&#39;\n    age 1\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>The name of the factory is prefixed with the name of the gem to ensure that we aren’t going to create a collision if someone has already defined a factory named <code class=\"language-text\">book</code> in their application. Now we need to expose the factory in <code class=\"language-text\">lib/gem_with_database.rb</code> and we can move onto setting up our test database.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">require &#39;gem_with_database/factories/author&#39;</code>\n        </deckgo-highlight-code>\n<p>We’ll modify <code class=\"language-text\">spec/spec_helper.rb</code> to create a database in the test environment for us to use.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">ENV[&#39;ENV&#39;] = &#39;test&#39; # Ensure we don&#39;t drop the development database\n\nrequire &#39;bundler/gem_tasks&#39;\nrequire_relative &#39;../support/active_record_rake_tasks&#39;\ntask :environment\n\nRake::Task[&#39;db:drop&#39;].invoke\nRake::Task[&#39;db:create&#39;].invoke\nRake::Task[&#39;db:schema:load&#39;].invoke</code>\n        </deckgo-highlight-code>\n<p>First and foremost we need to set the <code class=\"language-text\">ENV</code> to <code class=\"language-text\">test</code> to ensure that we’re targeting only the test database; remember we set up the <code class=\"language-text\">DatabaseTasks.env</code> to read from <code class=\"language-text\">ENV[&#39;ENV&#39;]</code>. Then we load the needed files to invoke our rake tasks, stub out the <code class=\"language-text\">task :environment</code> like we did in the <code class=\"language-text\">Rakefile</code>, and create a new database with our schema. Let’s write a test for our <code class=\"language-text\">Author</code> class at <code class=\"language-text\">spec/models/author_spec.rb</code> and try it out.</p>\n<deckgo-highlight-code language=\"ruby\"  >\n          <code slot=\"code\">require &#39;spec_helper&#39;\n\nRSpec.describe GemWithDatabase::Author do\n  it &#39;is a test author&#39; do\n    author = FactoryBot.create(:gem_with_database_author)\n    expect(author.name).to eq(&#39;Test Author&#39;)\n  end\nend</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">$ rspec\nDropped database &#39;gem_with_database_test&#39;\nCreated database &#39;gem_with_database_test&#39;\n-- enable_extension(&quot;plpgsql&quot;)\n   -&gt; 0.0392s\n-- create_table(&quot;authors&quot;, {:force=&gt;:cascade})\n   -&gt; 0.0093s\n-- create_table(&quot;books&quot;, {:force=&gt;:cascade})\n   -&gt; 0.0112s\n-- add_foreign_key(&quot;books&quot;, &quot;authors&quot;)\n   -&gt; 0.0209s\n\nGemWithDatabase\n  has a version number\n\nGemWithDatabase::Author\n  is a test author\n\nFinished in 0.02844 seconds (files took 2.13 seconds to load)\n2 examples, 0 failures</code>\n        </deckgo-highlight-code>\n<p>Success! We’ve created a re-usable database for the test environment and our tests are passing. The last thing we want to do is setup a way to run our tests in a continuous integration environment so that when the popularity of the gem has exploded and the number of contributors skyrockets, we’re able to ensure no one is committing broken code. We’ll do this by creating a <code class=\"language-text\">Dockerfile</code>, utilizing <a href=\"https://docs.docker.com/compose/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker Compose</a>, and a few helpful scripts. However, please bear with me, I am by no means an expert with Docker; I’ve was able to fumble my way through this and get it working so if my explanations aren’t as thorough I apologize.</p>\n<p>First, the <a href=\"https://github.com/jer-k/gem_with_database/blob/old_dockerfile/Dockerfile\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dockerfile</a>.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">FROM ruby:2.5\nWORKDIR /usr/src/app/\n\n#Copy the gem files into the WORKDIR\nCOPY gem_with_database.gemspec .\nCOPY Gemfile .\nCOPY lib/gem_with_database/version.rb lib/gem_with_database/\n\nRUN bundle check || bundle install\n\n# Install psql so bin/wait_for_pg.sh will wait for the database to be up and running\n# Get the Key\nRUN wget --quiet https://www.postgresql.org/media/keys/ACCC4CF8.asc\nRUN apt-key add ACCC4CF8.asc\n\n# Add the Source List\nRUN echo &quot;deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list\n\n# Update and Install\nRUN apt-get update &amp;&amp; apt-get -y install postgresql-client-9.6\n\n#Copy the project into the WORKDIR\nCOPY . .</code>\n        </deckgo-highlight-code>\n<p>The <code class=\"language-text\">ruby:2.5</code> image as it is the latest as of writing so we’ll use that and we set the <code class=\"language-text\">WORKDIR</code> to <code class=\"language-text\">/usr/src/app</code>. Next we copy in the <code class=\"language-text\">.gemspec</code> file, the <code class=\"language-text\">Gemfile</code>, and the <code class=\"language-text\">version.rb</code> because it is referenced in the <code class=\"language-text\">.gemspec</code>. Then we run <code class=\"language-text\">bundle check || bundle install</code> which will check to see if we need to run <code class=\"language-text\">bundle install</code> or not, hopefully saving time and not requiring a full install of all the gems each time we use the container. Next, I want to install <code class=\"language-text\">postgresl-client</code> so that we have access to <code class=\"language-text\">psql</code> and can run the <code class=\"language-text\">wait_for_pg.sh</code> script below. I slightly modified the Docker instructions for installing <a href=\"https://docs.docker.com/engine/examples/postgresql_service/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Postgresql</a>. Finally, we copy in the entire contents of the gem.</p>\n<p>The <code class=\"language-text\">docker-compose.yml</code> adds the <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v2/#entrypoint\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">entrypoint</a> which takes in a parameter, the name of the postgres database we defined, <code class=\"language-text\">db</code>. Otherwise we add the environment variables for postgres and builds the image.</p>\n<deckgo-highlight-code language=\"yaml\"  >\n          <code slot=\"code\">version: &#39;2&#39;\nservices:\n  app:\n    entrypoint: ./bin/wait_for_pg.sh db\n    build: .\n    volumes:\n      - .:/app\n    environment:\n      POSTGRES_HOST: db\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: &#39;&#39;\n    depends_on:\n      - db\n  db:\n    image: postgres\n    ports:\n      - &quot;5432&quot;</code>\n        </deckgo-highlight-code>\n<p>We’ll create a <code class=\"language-text\">bin/wait_for_pg.sh</code> script, which the code was taken from the <a href=\"https://docs.docker.com/compose/startup-order/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Control startup order in Compose</a> page.</p>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">#!/bin/bash\n\nset -e\n\nhost=&quot;$1&quot;\nshift\ncmd=&quot;$@&quot;\n\nuntil psql -h &quot;$host&quot; -U &quot;postgres&quot; -c &#39;\\l&#39;; do\n  &gt;&amp;2 echo &quot;Postgres is unavailable - sleeping&quot;\n  sleep 1\ndone\n\n&gt;&amp;2 echo &quot;Postgres is up - executing command&quot;\nexec $cmd</code>\n        </deckgo-highlight-code>\n<p>One last script to run our tests which will be <code class=\"language-text\">bin/ci.sh</code>.</p>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">#!/bin/bash -e\n\ndocker-compose build --pull\ndocker-compose run \\\n  -e &quot;RAILS_ENV=test&quot; \\\n  app bundle exec rake spec</code>\n        </deckgo-highlight-code>\n<p>We tell <code class=\"language-text\">docker-compose</code> to <code class=\"language-text\">build</code> our image and pass <code class=\"language-text\">--pull</code> to ensure it always pulls the most up to date base image. Then we tell <code class=\"language-text\">docker-compose</code> to <code class=\"language-text\">run</code> <code class=\"language-text\">app bundle exec rake spec</code>, using <code class=\"language-text\">-e</code> to pass an environment variable of <code class=\"language-text\">RAILS_ENV=test</code>. We can now run <code class=\"language-text\">bin/ci.sh</code> and we should see Docker build everything and run our tests!</p>\n<deckgo-highlight-code language=\"bash\"  >\n          <code slot=\"code\">$ bin/ci.sh\ndb uses an image, skipping\nBuilding app\nStep 1/11 : FROM ruby:2.5\n2.5: Pulling from library/ruby\nDigest: sha256:ed5fc221d5d03d89e1f8c1f7780b98bc708e68b4d8dba73594d017e999156619\nStatus: Image is up to date for ruby:2.5\n ---&gt; bae0455cb2b9\nStep 2/11 : WORKDIR /usr/src/app/\n ---&gt; Using cache\n ---&gt; 6f3c5f15ac42\nStep 3/11 : COPY gem_with_database.gemspec .\n ---&gt; Using cache\n ---&gt; eb3ecc2ee4cf\nStep 4/11 : COPY Gemfile .\n ---&gt; Using cache\n ---&gt; cc6f4fb53b10\nStep 5/11 : COPY lib/gem_with_database/version.rb lib/gem_with_database/\n ---&gt; Using cache\n ---&gt; 687de04b34df\nStep 6/11 : RUN bundle check || bundle install\n ---&gt; Using cache\n ---&gt; bc457854c58b\nStep 7/11 : RUN wget --quiet https://www.postgresql.org/media/keys/ACCC4CF8.asc\n ---&gt; Using cache\n ---&gt; 889e0f4155b1\nStep 8/11 : RUN apt-key add ACCC4CF8.asc\n ---&gt; Using cache\n ---&gt; 9c312fe432e9\nStep 9/11 : RUN echo &quot;deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list\n ---&gt; Using cache\n ---&gt; 2cc90fde777c\nStep 10/11 : RUN apt-get update &amp;&amp; apt-get -y install postgresql-client-9.6\n ---&gt; Using cache\n ---&gt; b50c64265bb8\nStep 11/11 : COPY . .\n ---&gt; 647917bd7233\nSuccessfully built 647917bd7233\nSuccessfully tagged gemwithdatabase_app:latest\nStarting gemwithdatabase_db_1 ... done\n                                       List of databases\n          Name          |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges   \n------------------------+----------+----------+------------+------------+-----------------------\n gem_with_database_test | postgres | UTF8     | en_US.utf8 | en_US.utf8 | \n postgres               | postgres | UTF8     | en_US.utf8 | en_US.utf8 | \n template0              | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n                        |          |          |            |            | postgres=CTc/postgres\n template1              | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n                        |          |          |            |            | postgres=CTc/postgres\n(4 rows)\n\nPostgres is up - executing command\n/usr/local/bin/ruby -I/usr/local/bundle/gems/rspec-core-3.7.0/lib:/usr/local/bundle/gems/rspec-support-3.7.0/lib /usr/local/bundle/gems/rspec-core-3.7.0/exe/rspec --pattern spec/\\*\\*\\{,/\\*/\\*\\*\\}/\\*_spec.rb\nDropped database &#39;gem_with_database_test&#39;\nCreated database &#39;gem_with_database_test&#39;\n-- enable_extension(&quot;plpgsql&quot;)\n   -&gt; 0.0256s\n-- create_table(&quot;authors&quot;, {:force=&gt;:cascade})\n   -&gt; 0.0503s\n-- create_table(&quot;books&quot;, {:force=&gt;:cascade})\n   -&gt; 0.0251s\n-- add_foreign_key(&quot;books&quot;, &quot;authors&quot;)\n   -&gt; 0.0120s\n\nGemWithDatabase\n  has a version number\n\nGemWithDatabase::Author\n  is a test author\n\nFinished in 0.03851 seconds (files took 2.74 seconds to load)\n2 examples, 0 failures</code>\n        </deckgo-highlight-code>\n<p>We’ve successfully created our testing environment and got it running in Docker (I did run into some issues with needing to add specific versions of gems.) Hopefully this provides a good blueprint to follow for the next gem you create that might need access to a database and a testing environment.</p>","fields":{"slug":"testing-and-developer-scripts-for-active-record-gem","tagSlugs":["/tag/ruby/","/tag/rails/","/tag/ruby-gems/","/tag/ruby-on-rails/","/tag/postgres/","/tag/postgresql/","/tag/database/","/tag/docker/","/tag/test/","/tag/testing/","/tag/rspec/"]},"excerpt":"<p>Continuing to work on our <a href=\"https://jer-k.github.io/add-active-record-rake-tasks-to-gem/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gem with active_record rake tasks</a>, we still need to set up a testing environment that can be run locally and in a…</p>","frontmatter":{"date":"2018-03-12","description":"Set up a testing environment that can be run locally and in a repeatable fashion for continuous integration","tags":["ruby","rails","ruby-gems","ruby-on-rails","postgres","postgresql","database","docker","test","testing","rspec"],"title":"Adding a Test Environment to the Active Record Rake Tasks Gem"}}},"pageContext":{"slug":"testing-and-developer-scripts-for-active-record-gem"}},"staticQueryHashes":["251939775","2920561799","401334301"]}