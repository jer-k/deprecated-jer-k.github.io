{"componentChunkName":"component---src-templates-post-template-js","path":"/github-webhook-authentication-with-elixir-plug","result":{"data":{"markdownRemark":{"id":"25635264-ed2a-5716-8066-725fd7bb4189","html":"<p>Recently, I started working on a new side project in Elixir and I think I’ve finally found something I’m going to stick with! In the past I would either build something like a simple TODO app and not get far enough into the language or I would pick a gigantic idea and get nowhere due to how daunting it was. However, one of my co-workers recently implemented a feature through the <a href=\"https://developer.github.com/webhooks/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Github Webhooks API</a> where we are required to add a label to our Pull Requests and a Slack channel is notified that the PR is ready to be reviewed. I decided that I wanted to rebuild it in Elixir and in doing so, be able to write about what I learn along the way; this is the first in what I hope to be many posts about my journey. With that said, if you’re unfamiliar with the webhooks API or how to set it up on your repository, please read the link above because we’re jumping right in!</p>\n<p>We’re going to create a <a href=\"https://hexdocs.pm/plug/Plug.Router.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Plug</a> that will read the secret from the webhooks API and halt the connection if the request does not authenticate. We’ll start off with a basic outline of what we want to do.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defmodule MyApp.Plugs.GithubAuthentication do\n  import Plug.Conn\n\n  def init(_params) do\n  end\n\n  def call(conn, _params) do\n    with {:ok, digest} &lt;- get_signature_digest(conn),\n           {:ok, secret} &lt;- get_secret(),\n           {:ok} &lt;- valid_request?(digest, secret, conn)\n    do\n      conn\n    else\n      _ -&gt; conn |&gt; send_resp(401, &quot;Couldn&#39;t Authenticate&quot;) |&gt; halt()\n    end\n  end\n\n  defp get_signature_digest(conn) do\n  end\n\n  defp get_secret do\n  end\n\n  defp valid_request?(digest, secret, conn) do\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>The first thing I want to note is that I never understood <code class=\"language-text\">with</code> until now. When it was introduced, the syntax threw me off and since I wasn’t writing much Elixir at the time, it never clicked. However, I’m happy that I understand it now because it is the perfect construct for what we want to do.</p>\n<p>First, we want to get the signature of the request that Github has sent. If we look at the <a href=\"https://developer.github.com/webhooks/#payloads\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Payloads</a> section of the API docs we’ll see that Github adds a <code class=\"language-text\">X-Hub-Signature</code> header to each request. It is described as</p>\n<blockquote>\n<p>The HMAC hex digest of the response body.\nThis header will be sent if the webhook is configured with a secret.\nThe HMAC hex digest is generated using the sha1 hash function and the secret as the HMAC key.</p>\n</blockquote>\n<p>which we will come back to a little later when we need to build the digest ourselves, but for now let’s fill in <code class=\"language-text\">get_signature_digest</code> to grab the header from the request. Plug has a function to help us do this <a href=\"https://hexdocs.pm/plug/Plug.Conn.html#get_req_header/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">get<em>req</em>header/2</a> so let’s use that.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defp get_signature_digest(conn) do\n  case get_req_header(conn, &quot;x-hub-signature&quot;) do\n    [&quot;sha1=&quot; &lt;&gt; digest] -&gt; {:ok, digest}\n    _ -&gt; {:error, &quot;No Github Signature Found&quot;}\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>If we look at the <a href=\"https://developer.github.com/webhooks/#example-delivery\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Example delivery</a> from Github, it shows</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">X-Hub-Signature: sha1=7d38cdd689735b008b3c702edd92eea23791c5f6</code>\n        </deckgo-highlight-code>\n<p>so what we want to do is pattern match on the header value to ensure it is formed correctly with <code class=\"language-text\">sha1=</code> precreeding the digest and then return the digest.</p>\n<p>Next we need to know the secret that was used to create the digest. For this example I’m going to use <a href=\"https://hexdocs.pm/elixir/Application.html#get_env/3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Application.get_env</a>.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defp get_secret\n  Application.get_env(:my_app, :github_secret)\nend</code>\n        </deckgo-highlight-code>\n<p>However, this is a very basic use case that will work if we only have one a single key to handle, but what if we were building an application that handled requests from many repositories? That is what the project I’m working on will do so I need to be able to find the secrets based on the repository sending the event. While I’m not going to cover that implementation here, what it means is that I need to have the parsed request body available at the time <code class=\"language-text\">get_secret</code> is called; I would probably have a <code class=\"language-text\">get_secret/1</code> which took in the repository url. For now let’s continue on, but we’ll see why needing access to the parsed and raw response bodies matter.</p>\n<p>Now that we have both the digest and the secret in hand, we need to rebuild the digest from the request to see if we have a match. Looking back at the description of the <code class=\"language-text\">X-Hub-Signature</code>, it starts off with <code class=\"language-text\">The HMAC hex digest of the response body.</code> What we need is access not to the parsed response body, but to the raw response body. Thankfully this exact type of functionality was added to Plug in the form of a <a href=\"https://hexdocs.pm/plug/Plug.Parsers.html#module-custom-body-reader\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Custom body reader</a>; we just need to copy the docs into our application!</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defmodule MyApp.Plugs.CacheBodyReader do\n  def read_body(conn, opts) do\n    {:ok, body, conn} = Plug.Conn.read_body(conn, opts)\n    conn = update_in(conn.assigns[:raw_body], &amp;[body | (&amp;1 || [])])\n    {:ok, body, conn}\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>We’ll come back to where to put this code when we wrap up, but for now we know that <code class=\"language-text\">conn.assigns.raw_body</code> exists so let’s put it to use in <code class=\"language-text\">valid_request?</code>.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defp valid_request?(digest, secret, conn) do\n  hmac = :crypto.hmac(:sha, secret, conn.assigns.raw_body) |&gt; Base.encode16(case: :lower)\n  if Plug.Crypto.secure_compare(digest, hmac), do: {:ok}, else: {:error}\nend</code>\n        </deckgo-highlight-code>\n<p>We generate the hmac using Erlang’s <a href=\"http://erlang.org/doc/man/crypto.html#hmac-3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">crypto</a> library and then encode it to lowercase to ensure it matches the form of Github’s signature. At the very bottom of Github’s <a href=\"https://developer.github.com/webhooks/securing/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Securing your webhooks</a> they note</p>\n<blockquote>\n<p>Using a plain == operator is not advised.\nA method like secure_compare performs a “constant time” string comparison,\nwhich renders it safe from certain timing attacks against regular equality operators.</p>\n</blockquote>\n<p>so to compare the two digests, we’ll use <a href=\"https://hexdocs.pm/plug/Plug.Crypto.html#secure_compare/2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Plug.Crypto.secure_compare</a>. The entire Plug now looks like this.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defmodule MyApp.Plugs.GithubAuthentication do\n  import Plug.Conn\n\n  def init(_params) do\n  end\n\n  def call(conn, _params) do\n    with {:ok, digest} &lt;- get_signature_digest(conn),\n         {:ok, secret} &lt;- get_secret(),\n         {:ok} &lt;- valid_request?(digest, secret, conn)\n    do\n      conn\n    else\n      _ -&gt; conn |&gt; send_resp(401, &quot;Couldn&#39;t Authenticate&quot;) |&gt; halt()\n    end\n  end\n\n  defp get_signature_digest(conn) do\n    case get_req_header(conn, &quot;x-hub-signature&quot;) do\n      [&quot;sha1=&quot; &lt;&gt; digest] -&gt; {:ok, digest}\n      _ -&gt; {:error, &quot;No Github Signature Found&quot;}\n    end\n  end\n\n  defp get_secret\n    Application.get_env(:my_app, :github_secret)\n  end\n\n  defp valid_request?(digest, secret, conn) do\n    hmac = :crypto.hmac(:sha, secret, conn.assigns.raw_body) |&gt; Base.encode16(case: :lower)\n    if Plug.Crypto.secure_compare(digest, hmac), do: {:ok}, else: {:error}\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>Now we can create a <a href=\"https://hexdocs.pm/plug/Plug.Router.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Router</a> and test out our implementation.</p>\n<deckgo-highlight-code language=\"elixir\"  >\n          <code slot=\"code\">defmodule MyApp.Router do\n  use Plug.Router\n\n  plug(Plug.Logger)\n  plug(Plug.Parsers,\n    parsers: [:json],\n    body_reader: {MyApp.Plugs.CacheBodyReader, :read_body, []},\n    json_decoder: Jason)\n  plug(MyApp.Plugs.GithubAuthentication)\n  plug(:match)\n  plug(:dispatch)\n\n  post &quot;events&quot; do\n    send_resp(conn, 200, &quot;Successful Event!&quot;)\n  end\nend</code>\n        </deckgo-highlight-code>\n<p>The ordering of the plugs becomes important, remember that we want the parsed body available when we do the authentication so we need to put the <code class=\"language-text\">Parsers</code> plug above the <code class=\"language-text\">GithubAuthentication</code> plug. We need to add the <code class=\"language-text\">body_reader: {MyApp.Plugs.CacheBodyReader, :read_body, []},</code> line to ensure that the raw body is also available when we’re trying to authenticate. Finally we’ll add an endpoint to test the events and we should be good to go.</p>\n<p>Let’s try it out. I’m going to use <a href=\"https://ngrok.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ngrok</a> to expose a url Github can reach and then send over an event to ensure everything works. Then I’m going to change the secret in the application to “not<em>the</em>secret” and the response should be a 401.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">Session Status                online\nSession Expires               7 hours, 40 minutes\nVersion                       2.3.34\nRegion                        United States (us)\nWeb Interface                 http://127.0.0.1:4040\nForwarding                    http://9f3e1658.ngrok.io -&gt; http://localhost:4001\nForwarding                    https://9f3e1658.ngrok.io -&gt; http://localhost:4001\nConnections                   ttl     opn     rt1     rt5     p50     p90\n                              2       0       0.00    0.00    0.19    0.23\nHTTP Requests\n-------------\nPOST /events                  200 OK\nPOST /events                  401 Unauthorized</code>\n        </deckgo-highlight-code>\n<p>We can look at those events in Github too.</p>\n<p><img src=\"media/successful_event.png\" alt=\"successful_event\"></p>\n<p><img src=\"media/unauthorized_event.png\" alt=\"unauthorized_event\"></p>\n<p>We successfully added a plug to authenticate the Github Webhooks API! I’m super excited to keep working on this project and I hope that I’ll have more to share in the future!</p>","fields":{"slug":"github-webhook-authentication-with-elixir-plug","tagSlugs":["/tag/github/","/tag/webhook/","/tag/webhooks/","/tag/elixir/","/tag/plug/","/tag/authenticate/","/tag/authentication/"]},"excerpt":"<p>Recently, I started working on a new side project in Elixir and I think I’ve finally found something I’m going to stick with! In the past I…</p>","frontmatter":{"date":"2019-08-17","description":"Recently, I started working on a new side project in Elixir and I think I've finally found something I'm going to stick with; a service where we are required to add a label to our Pull Requests and a Slack channel is notified that the PR is ready to be reviewed","tags":["github","webhook","webhooks","elixir","plug","authenticate","authentication"],"title":"Authenticate Github's Webhooks API using Elixir's Plug"}}},"pageContext":{"slug":"github-webhook-authentication-with-elixir-plug"}},"staticQueryHashes":["251939775","2920561799","401334301"]}